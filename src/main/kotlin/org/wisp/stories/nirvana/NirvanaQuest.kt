package org.wisp.stories.nirvana

import com.fs.starfarer.api.campaign.PlanetAPI
import com.fs.starfarer.api.campaign.SectorEntityToken
import com.fs.starfarer.api.campaign.StarSystemAPI
import com.fs.starfarer.api.campaign.econ.MarketAPI
import com.fs.starfarer.api.impl.campaign.ids.*
import com.fs.starfarer.api.impl.campaign.procgen.PlanetGenDataSpec
import com.fs.starfarer.api.impl.campaign.procgen.StarGenDataSpec
import com.fs.starfarer.api.impl.campaign.terrain.StarCoronaTerrainPlugin.CoronaParams
import com.fs.starfarer.api.util.Misc
import org.lwjgl.util.vector.Vector2f
import org.wisp.stories.MOD_PREFIX
import org.wisp.stories.game
import wisp.questgiver.*
import wisp.questgiver.wispLib.*
import kotlin.random.Random

object NirvanaQuest : AutoQuestFacilitator(
    stageBackingField = PersistentData(key = "nirvanaStage", defaultValue = { Stage.NotStarted }),
    autoBarEvent = AutoBarEvent(Nirvana_Stage1_BarEventCreator()) { market ->
        market.factionId.toLowerCase() in listOf(Factions.INDEPENDENT.toLowerCase())
                && market.size > 3
                && NirvanaQuest.destPlanet != null
    },
    autoIntel = AutoIntel(NirvanaIntel::class.java) {
        NirvanaIntel(NirvanaQuest.startLocation!!, NirvanaQuest.destPlanet!!)
    }
) {

    val REWARD_CREDITS: Float
        get() = Questgiver.calculateCreditReward(startLocation, destPlanet, scaling = 1.3f)
    const val CARGO_TYPE = Commodities.HEAVY_MACHINERY
    const val CARGO_WEIGHT = 5

    val icon = InteractionDefinition.Portrait(category = "wisp_perseanchronicles_nirvana", id = "davidRengel")
    val background = InteractionDefinition.Illustration(category = "wisp_perseanchronicles_nirvana", id = "background")

    var startDate: Long? by PersistentNullableData("nirvanaStartDate")
        private set

    var startLocation: SectorEntityToken? by PersistentNullableData("nirvanaStartLocation")
        private set

    var destPlanet: SectorEntityToken? by PersistentNullableData("nirvanaDestPlanet")
        private set

    val destSystem: StarSystemAPI?
        get() = destPlanet?.starSystem

    override fun updateTextReplacements(text: Text) {
        text.globalReplacementGetters["nirvanaCredits"] = { Misc.getDGSCredits(REWARD_CREDITS) }
        text.globalReplacementGetters["nirvanaDestPlanet"] = { destPlanet?.name }
        text.globalReplacementGetters["nirvanaDestSystem"] = { destSystem?.name }
        text.globalReplacementGetters["nirvanaCargoTons"] = { CARGO_WEIGHT.toString() }
        text.globalReplacementGetters["nirvanaStarName"] = { destPlanet?.starSystem?.star?.name }
    }

    override fun regenerateQuest(interactionTarget: SectorEntityToken, market: MarketAPI?) {
        this.startLocation = interactionTarget

        val system = game.sector.starSystemsNotOnBlacklist
            .filter { sys -> sys.star.spec.isPulsar }
            .prefer { it.distanceFromPlayerInHyperspace >= 18 } // 18+ LY away
            .ifEmpty {
                createPulsarSystem()
                regenerateQuest(interactionTarget, market)
                return
            }
            .let { pulsarSystems ->
                val pulsarSystemsWithPlanet =
                    pulsarSystems.filter { sys -> sys.solidPlanets.any { isValidPlanetForDestination(it) } }

                return@let if (pulsarSystemsWithPlanet.isEmpty()) {
                    val system = pulsarSystems.random()
                    addPlanetToSystem(system)
                    system
                } else {
                    pulsarSystemsWithPlanet.random()
                }
            }

        val planet = system.solidPlanets
            .filter { isValidPlanetForDestination(it) }
            .minBy { it.market?.hazardValue ?: 500f }
            ?: kotlin.run {
                // This should never happen, the system should be generated by this point.
                game.errorReporter.reportCrash(NullPointerException("No planet found in ${system.name} for Nirvana quest."))
                return
            }

        // Change the planet to be tidally locked so there's a realistic place to set up a base camp.
        planet.spec.rotation = 0f
        planet.applySpecChanges()

        destPlanet = planet
    }

    fun start(startLocation: SectorEntityToken) {
        game.logger.i { "Nirvana start location set to ${startLocation.fullName} in ${startLocation.starSystem.baseName}" }
        stage = Stage.GoToPlanet
        game.sector.playerFleet.cargo.addCommodity(CARGO_TYPE, CARGO_WEIGHT.toFloat())
    }

    fun shouldShowStage2Dialog() =
        stage == Stage.GoToPlanet
                && game.sector.playerFleet.cargo.getCommodityQuantity(CARGO_TYPE) >= CARGO_WEIGHT

    fun complete() {
        stage = Stage.Completed

        game.sector.playerFleet.cargo.removeCommodity(CARGO_TYPE, CARGO_WEIGHT.toFloat())
        game.sector.playerFleet.cargo.credits.add(REWARD_CREDITS)
    }

    /**
     * 55 years after quest was completed.
     */
    fun shouldShowStage3Dialog() =
        stage == Stage.Completed
                && game.sector.clock.convertToMonths(startDate?.toFloat() ?: 0f) > (12 * 55)

    fun completeSecret() {
        stage = Stage.CompletedSecret
    }

    fun restartQuest() {
        game.logger.i { "Restarting Nirvana quest." }

        startDate = null
        startLocation = null
        destPlanet = null
        stage = Stage.NotStarted
    }

    private fun isValidPlanetForDestination(planet: PlanetAPI): Boolean =
        (planet.faction?.isHostileTo(game.sector.playerFaction) != true)
                && planet.market?.factionId?.toLowerCase() !in listOf("luddic_church", "luddic_path")
                && !planet.isGasGiant
                && !planet.isStar

    fun createPulsarSystem(): Boolean {
        if (game.sector.getStarSystem(game.text["nirv_starSystem_name"]) != null) {
            return false
        }

        // Create the system
        val newSystem = game.sector.createStarSystem(game.text["nirv_starSystem_name"])

        // Create the neutron star
        // Adapted from StarSystemGenerator.addStars
        val spec =
            game.settings.getSpec(StarGenDataSpec::class.java, StarTypes.NEUTRON_STAR, false) as StarGenDataSpec
        val radius = (spec.minRadius..spec.maxRadius).random()
        var corona: Float =
            radius * (spec.coronaMult + spec.coronaVar * (Random.nextFloat() - 0.5f))
        if (corona < spec.coronaMin) corona = spec.coronaMin

        val star = newSystem.initStar(
            "${MOD_PREFIX}_nirvana_star",
            StarTypes.NEUTRON_STAR,
            radius,
            corona,
            spec.solarWind,
            (spec.minFlare..spec.maxFlare).random(),
            spec.crLossMult
        )

        newSystem.lightColor = Misc.interpolateColor(spec.lightColorMin, spec.lightColorMax, Random.nextFloat())
        newSystem.star = star

        // Adapted from StarSystemGenerator.setPulsarIfNeutron
        val coronaPlugin = Misc.getCoronaFor(star)

        if (coronaPlugin != null) {
            newSystem.removeEntity(coronaPlugin.entity)
        }

        newSystem.addCorona(star, 300f, 3f, 0f, 3f) // cr loss

        val eventHorizon: SectorEntityToken = newSystem.addTerrain(
            Terrain.PULSAR_BEAM,
            CoronaParams(
                star.radius + corona, (star.radius + corona) / 2f,
                star,
                spec.solarWind,
                (spec.minFlare..spec.maxFlare).random(),
                spec.crLossMult
            )
        )
        eventHorizon.setCircularOrbit(star, 0f, 0f, 100f)

        // Add planet
        addPlanetToSystem(newSystem)

        // Find a constellation to add it to
        val constellations =
            game.sector.getConstellations()
                // Prefer an un-visited constellation
                .prefer { it.systems.all { system -> system.lastPlayerVisitTimestamp == 0L } }
                .sortedByDescending { it.location.distanceFromPlayerInHyperspace }

        // Need to put in hyperspace and generate jump points so we have a maxRadiusInHyperspace
        newSystem.autogenerateHyperspaceJumpPoints(true, true)

        for (constellation in constellations) {
            val xCoords = constellation.systems.mapNotNull { it.location.x }
            val yCoords = constellation.systems.mapNotNull { it.location.y }

            // Try 5000 points
            for (i in 0..5000) {
                val point =
                    Vector2f((xCoords.min()!!..xCoords.max()!!).random(), (yCoords.min()!!..yCoords.max()!!).random())


                val doesPointIntersectWithAnySystems = constellation.systems.any { system ->
                    doCirclesIntersect(
                        centerA = point,
                        radiusA = newSystem.maxRadiusInHyperspace,
                        centerB = system.location,
                        radiusB = system.maxRadiusInHyperspace
                    )
                }

                if (!doesPointIntersectWithAnySystems) {
                    newSystem.constellation = constellation
                    constellation.systems.add(newSystem)
                    newSystem.location.set(point)
                    newSystem.autogenerateHyperspaceJumpPoints(true, true)
                    game.logger.i { "System ${newSystem.baseName} added to the ${constellation.name} constellation." }
                    return true
                }
            }
        }

        game.logger.i { "Failed to find anywhere to add a new system!" }
        return false
    }

    fun addPlanetToSystem(system: StarSystemAPI) {
        val planetType = "barren"
        val spec = game.settings.getSpec(PlanetGenDataSpec::class.java, planetType, false) as PlanetGenDataSpec
        val planet = system.addPlanet(
            "${MOD_PREFIX}_nirvana_planet",
            system.star,
            game.text["nirv_starSystem_planetName"],
            planetType,
            0f,
            (spec.minRadius..spec.maxRadius).random(),
            3000f,
            50f
        )
        Misc.initConditionMarket(planet)
        planet.market.addCondition(Conditions.IRRADIATED)
    }

    abstract class Stage(progress: Progress) : AutoQuestFacilitator.Stage(progress) {
        object NotStarted : Stage(Progress.NotStarted)
        object GoToPlanet : Stage(Progress.InProgress)
        object Completed : Stage(Progress.Completed)
        object CompletedSecret : Stage(Progress.Completed)
    }
}